module Int64Map = Map.Make(Int64)
open Capnptk.Declarative
open Schema


module StringSet = Set.Make(String)


let rec rstrip chr str =
  let l = String.length str in
  if str.[l - 1] = chr then
    rstrip chr (String.sub str 0 (l - 1))
  else
    str

let sanitize_name =
  let keywords = StringSet.of_list [
    "field";
    "t";
    "union";
    "union_tag";
    "c";
    "sg";
    "ig";
    "type";
    "union";
    "object"; 
    "module"; 
    "struct"; 
    "let"; 
    "in"; 
    "open"; 
    "import"; 
    "end"; 
    "begin"; 
    "done"; 
    "for"; 
    "do";
    "true";
    "false";
    "method";
    "Self";
  ]
   in
   fun name ->
     match StringSet.mem (rstrip '_' name) keywords with
     | true -> name ^ "_"
     | false -> name

let node_name ?(capitalize=true) node =
  let p = node => Node.displayNamePrefixLength |> Int32.to_int in
  let s = node => Node.displayName in
  let n = String.length s in
  String.sub s p (n - p) |> (fun x -> 
    if capitalize then String.capitalize_ascii x else x) |> sanitize_name

let rec node_chain get_node node =
  node => Node.scopeId |> function
    | 0L -> [node]
    | id -> node :: (id |> get_node |> node_chain get_node)

let rec show_node_head fmt get_node (petname,node) =
  let open Codegen in
  match node => Node.union with
  | File ->
      fmt |> open_top |>
      comment "This file was generated by capnptk. It is probably not a good idea to edit it." |>
      statement_open "Capnptk.Declarative" |> open_head |> ignore;

      node => Node.nestedNodes |> Array.iter (fun n -> 
        (n => Node.NestedNode.name, n => Node.NestedNode.id |> get_node) |>
        show_node_head fmt get_node |> ignore);

      fmt |>  close_module
  | Struct s ->
      let name = petname |> String.capitalize_ascii in
      fmt |> 
      open_module name |> 
      (if node => Node.isGeneric then
        comment "GENERIC!"
      else
        fun x -> x)
      |>

      structure_type (s=>Node.Struct.dataWordCount) (s=>Node.Struct.pointerCount) |>
      (fun fmt -> 
        (* we also need to get any fields that represent groups *)
        node => Node.nestedNodes |> Array.iter (fun x -> 
          (x => Node.NestedNode.name, x => Node.NestedNode.id |> get_node) |> 
          show_node_head fmt get_node |> ignore); 
        s => Node.Struct.fields |> Array.iter (fun x -> 
          match x => Field.union with
          | Group g ->
              (x => Field.name, g => Field.Group.typeId |> get_node) |> show_node_head fmt get_node |> ignore
          | _ -> ());
          fmt) |>
      close_module 


  | Interface _ -> 
      let name = node |> node_name in
      fmt |> 
      open_module name |> 
      interface_type  (node => Node.id) |>
      close_module

  | Enum e -> 
      let name = node |> node_name in
      let enumerants = 
        e => Node.Enum.enumerants |> Array.map (fun x -> 
          x => Enumerant.name |> String.capitalize_ascii)
      in
      fmt |> 
      open_module name |>
      enum_type enumerants |>
      close_module 

  (* We don't define consts until implementation *)
  | Const _ | Annotation _ -> fmt

let qualified_name get_node node = 
  let (nodes, files) = 
    node |>
    node_chain get_node |>
    List.partition (fun n -> 
      n => Node.union |> function | File -> false | _ -> true)
  in
  (nodes |> List.map (node_name) |> List.rev |> String.concat ".", files |> List.map (get Node.displayName))
  

let ocaml_literal value =
  let fmt = Printf.sprintf in
  match value => Value.union with
  | Void -> None
  | Bool v -> if v then Some "true" else None
  | Int8 v | Int16 v | Uint8 v | Uint16 v ->
      if v = 0 then None else Some (fmt "%d" v)
  | Int32 v | Uint32 v ->
      if v = 0l then None else Some (fmt "0x%lxl" v)
  | Int64 v | Uint64 v ->
      if v = 0L then None else Some (fmt "0x%LxL" v)
  | Interface -> None
  | Text t | Data t -> if t = "" then None else Some (fmt "%S" t)
  | Float32 f | Float64 f -> 
      let bits = f |> Int64.bits_of_float in
      if bits = 0L then None else Some (fmt "%F" f)
  | List ap -> 
      ((ap |> c_read_ptr).ptr |> function
        | NullPtr -> None
        | _ -> failwith "boO")

  | Struct ap -> 
      ((ap |> c_read_ptr).ptr |> function
        | NullPtr -> None
        | _ -> failwith "boO")

  | Enum _ -> None

  | AnyPointer _ -> None


let rec ocaml_type get_node typ =
  let fmt = Printf.sprintf in
  let named_type id = id |> get_node |> qualified_name get_node |> fst |> fmt "Self.%s.t" in
  match typ => Type.union with
  | Void -> "unit"
  | Bool -> "bool"
  | Int8 -> "int"
  | Int16 -> "int"
  | Int32 -> "int32"
  | Int64 -> "int64"
  | Uint8 -> "int"
  | Uint16 -> "int"
  | Uint32 -> "int32"
  | Uint64 -> "int64"
  | Float32 -> "float"
  | Float64 -> "float"
  | Text -> "string"
  | Data -> "string"
  | List t -> 
      t => Type.List.elementType |> ocaml_type get_node |> fmt "%s array"
  | Enum e -> 
      e => Type.Enum.typeId |> named_type
  | Struct e -> 
      e => Type.Struct.typeId |> named_type |> Printf.sprintf "%s s c" 
  | Interface i ->
      i => Type.Interface.typeId |> named_type 
  | AnyPointer _ -> "unit c"

let rec capnptk_type get_node typ =
  let fmt = Printf.sprintf in
  let named_type id = id |> get_node |> qualified_name get_node |> fst |> fmt "Self.%s.t" in
  match typ => Type.union with
  | Void -> "Void"
  | Bool -> "Bool"
  | Int8 -> "Int8"
  | Int16 -> "Int16"
  | Int32 -> "Int32"
  | Int64 -> "Int64"
  | Uint8 -> "UInt8"
  | Uint16 -> "UInt16"
  | Uint32 -> "UInt32"
  | Uint64 -> "UInt64"
  | Float32 -> "Float32"
  | Float64 -> "Float64"
  | Text -> "Text"
  | Data -> "Data"
  | List t -> 
      t => Type.List.elementType |> capnptk_type get_node |> fmt "(List %s)"
  | Enum e -> 
      e => Type.Enum.typeId |> named_type |> fmt "%s"
  | Struct e -> 
      e => Type.Struct.typeId |> named_type |> fmt "(Ptr %s)"
  | Interface i ->
      i => Type.Interface.typeId |> named_type  |> fmt "%s"
  | AnyPointer _ -> "(Ptr Void)"


let capnptk_sizeof typ =
  match typ => Type.union with
  | Int8 | Uint8 -> 8l
  | Int16 | Uint16 | Enum _ -> 16l
  | Int32 | Uint32 | Float32 -> 32l
  | Int64 | Uint64 | Float64 -> 64l
  | _ -> 1l


let field_accessor get_node field =
  match field => Field.union with
    | Slot slot when slot => Field.Slot.type_ => Type.union = Void -> 
        None
    | Slot slot -> 
        let default = slot => Field.Slot.defaultValue |> ocaml_literal in
        let default = match default with 
        | Some d -> Printf.sprintf " ~default:(%s)" d
        | None -> ""
        in
        Some (Printf.sprintf "field t %s%s %ldl" 
        (slot => Field.Slot.type_ |> capnptk_type get_node)
        default
        (Int32.mul (slot => Field.Slot.offset) (slot => Field.Slot.type_ |> capnptk_sizeof)))
    | Group group -> 
        Some (Printf.sprintf "group t (Ptr Self.%s.t)" (group => Field.Group.typeId |> get_node |> qualified_name get_node |> fst))

let rec show_node_body fmt get_node node =
  let open Codegen in
  let name = node_name node in
  let qualified, _ = qualified_name get_node node in
  match node => Node.union with
  | File ->
      fmt |> 
      comment "Now we begin the body. This is what will be referenced by \
      outside scripts, so the first thing we do in each module is alias to the \
      types declared above. " |> open_body |> ignore;

      node => Node.nestedNodes |> Array.iter (fun n -> 
        n => Node.NestedNode.id |> get_node |>
        show_node_body fmt get_node |> ignore);

      fmt |> close_body |> close_top
  | Struct s ->
      fmt |> 
      open_body_module name |> 
      import_from_head qualified |> ignore;

      (* We should find out if the struct is a union. If it is, we should
       * iterate over all union fields *)

      Node.(node => nestedNodes |> Array.iter (fun x -> x => NestedNode.id |> get_node |> show_node_body fmt get_node |> ignore));

      s => Node.Struct.fields |> Array.iter (fun x -> 
        match x => Field.union with
        | Group g ->
            g => Field.Group.typeId |> get_node |> show_node_body fmt get_node |> ignore
        | _ -> ());
      
      let fields = s => Node.Struct.fields in

      let fields = match s => Node.Struct.discriminantCount with
        | 0 -> fields
        | n -> 
            let base_fields = Array.make ((Array.length fields) - n) fields.(0) in 
            let union_fields = Array.make n fields.(0) in 

            fields |> ((0, 0) |> Array.fold_left (fun (i, j) field ->
              match (field => Field.discriminantValue) with
              | n when n = Field.noDiscriminant -> 
                  base_fields.(i) <- field; (i+1, j)
              | _ -> 
                  union_fields.(j) <- field; (i, j+1))) |>
              (fun (_, j) ->
                if j <> n then 
                  failwith "discriminant count does not match discriminant count"
                else ());

            (* We have a union, so we had best output the stuff *)
            let open Format in
            fprintf fmt "@,@ @[<v 2>type union =";

            union_fields |> Array.iter (fun field -> 
              let fieldname = field => Field.name |> String.capitalize_ascii in
              match field => Field.union with
              | Slot slot when slot => Field.Slot.type_ => Type.union = Void ->
                  fprintf fmt "@ | %s" fieldname
              | Slot slot ->
                  fprintf fmt "@ | %s of %s" fieldname (slot => Field.Slot.type_ |> ocaml_type get_node)
              | Group group -> 
                  fprintf fmt "@ | %s of Self.%s.t s c" fieldname (group => Field.Group.typeId |> get_node |> qualified_name get_node |> fst)
            );

            fprintf fmt "@]";

            fprintf fmt "@ @[<v 2>let union =";
            fprintf fmt "@ let union_tag = field t UInt16 %ldl in" (s => Node.Struct.discriminantOffset |> Int32.mul 16l);
            fprintf fmt "@ @[<v 2>let f c =";
            fprintf fmt "@ @[<v 2>match c => union_tag with";

            union_fields |> Array.iter (fun field -> 
              let fieldname = field => Field.name |> String.capitalize_ascii in
              let tag = field => Field.discriminantValue in
              match field |> field_accessor get_node with
              | Some accessor -> 
                  fprintf fmt "@ | %d -> %s (c => (%s))" tag fieldname accessor
              | None -> 
                  fprintf fmt "@ | %d -> %s" tag fieldname
            );

            fprintf fmt "@ | n -> raise (Capnptk.OrdinalError n)";

            fprintf fmt "@]";
            fprintf fmt "@]@ in";


            fprintf fmt "@ @[<v 2>let g b = function";

            union_fields |> Array.iter (fun field -> 
              let fieldname = field => Field.name |> String.capitalize_ascii in
              let tag = field => Field.discriminantValue in
              match field |> field_accessor get_node with
              | Some accessor -> 
                  fprintf fmt "@ | %s v -> b |> set (%s) v |> set union_tag %d"
                  fieldname accessor tag
              | None -> 
                  fprintf fmt "@ | %s -> b |> set union_tag %d;" fieldname tag 
            );


            fprintf fmt "@]@ in ug f g";

            fprintf fmt "@]";


            base_fields
      in
      Format.fprintf fmt "@,";

      fields |> Array.iter (fun field ->
        let open Field in
        match field_accessor get_node field with
        | Some accessor ->
          Format.fprintf fmt "@ let %s = %s" (field => name |> sanitize_name) accessor
        | None ->
          ()

      );
      fmt |> close_module 

      (* we also need to get any fields that represent groups *)

  | Interface _ -> fmt
  | Enum _ -> 
      fmt |>
      open_body_module name |>
      import_from_head qualified |> 
      close_module 

  (* We don't define consts until implementation *)
  | Const c -> 
      let name = node_name ~capitalize:false node |> sanitize_name in
      Format.fprintf fmt "@ let %s = %s" name (c => Node.Const.value |> ocaml_literal |> function | Some x -> x | _ -> failwith "_"); fmt

  | Annotation _ -> fmt

let () =
  let cgr = Capnptk.Utils.(from_stdin () |> decode (CodeGeneratorRequest.t)) in

  let open Format in

  let fmt = std_formatter in


  let get_node = 
    let nodemap = cgr => CodeGeneratorRequest.nodes |> Int64Map.(
      empty |> Array.fold_left @@ 
      fun m x ->
        m |> add (x => Node.id) x
    )
    in
    fun k -> Int64Map.find k nodemap
  in

  get_node |> ignore;

  CodeGeneratorRequest.(cgr => requestedFiles |> Array.iter (
    fun file -> 
      file => RequestedFile.id |> get_node |> (fun n ->
        (file => RequestedFile.filename, n) |> show_node_head fmt get_node |> ignore;
        n |> show_node_body fmt get_node |> ignore)
  ));

